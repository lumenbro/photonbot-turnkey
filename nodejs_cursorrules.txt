# LumenBro Node.js Backend - Cursor Rules

## ðŸŽ¯ CRITICAL: SHARED DATABASE CONSISTENCY
âš ï¸ **This Node.js project shares the same PostgreSQL database with the Python bot. Schema changes must be coordinated.**

## DATABASE SCHEMA REQUIREMENTS

### Users Table (Must Match Python)
```sql
CREATE TABLE IF NOT EXISTS users (
    telegram_id BIGINT PRIMARY KEY,
    public_key TEXT,
    referral_code TEXT,
    turnkey_user_id TEXT,
    turnkey_session_id TEXT,
    temp_api_public_key TEXT,
    temp_api_private_key TEXT,
    session_expiry TIMESTAMP,
    kms_encrypted_session_key TEXT,
    kms_key_id TEXT,
    user_email TEXT,
    session_created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    source_old_db TEXT,                    -- Legacy migration flag
    encrypted_s_address_secret TEXT,        -- Legacy S-address secret
    migration_date TIMESTAMP,
    pioneer_status BOOLEAN DEFAULT FALSE,
    migration_notified BOOLEAN DEFAULT FALSE,
    migration_notified_at TIMESTAMP,
    legacy_public_key TEXT                 -- Old public key for legacy users
);
```

### Turnkey Wallets Table (Must Match Python)
```sql
CREATE TABLE IF NOT EXISTS turnkey_wallets (
    id BIGSERIAL PRIMARY KEY,
    telegram_id BIGINT REFERENCES users(telegram_id) ON DELETE CASCADE,
    turnkey_sub_org_id TEXT NOT NULL,
    turnkey_key_id TEXT NOT NULL,
    public_key TEXT NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(telegram_id, turnkey_key_id)
);
```

## KMS INTEGRATION REQUIREMENTS

### Shared KMS Configuration
- **Key ID**: `27958fe3-0f3f-44d4-b21d-9d820d5ad96c`
- **Region**: `us-west-1`
- **Usage**: Encrypt session keys in Node.js, decrypt in Python bot

### KMS Service Pattern
```javascript
// services/kmsService.js
const AWS = require('aws-sdk');
const kms = new AWS.KMS({ region: 'us-west-1' });

class KMSService {
  async encryptSessionKey(sessionKey) {
    const params = {
      KeyId: '27958fe3-0f3f-44d4-b21d-9d820d5ad96c',
      Plaintext: Buffer.from(sessionKey, 'utf8')
    };
    const result = await kms.encrypt(params).promise();
    return result.CiphertextBlob.toString('base64');
  }
}
```

## LEGACY USER SAFETY CHECKS

### Wallet Creation Safety (auth.js)
```javascript
// ALWAYS check for existing wallets before creating new ones
const existing = await pool.query(
  "SELECT turnkey_sub_org_id, turnkey_key_id, public_key FROM turnkey_wallets WHERE telegram_id = $1 AND is_active = TRUE",
  [telegram_id]
);
if (existing.rows.length > 0) {
  console.log(`Existing sub-org found for ${telegram_id}`);
  return { subOrgId: existing.rows[0].turnkey_sub_org_id, email };
}
```

### Legacy User Detection
```javascript
// Check if user is legacy migrated
const legacyUser = await pool.query(
  "SELECT source_old_db, encrypted_s_address_secret FROM users WHERE telegram_id = $1 AND source_old_db IS NOT NULL",
  [telegram_id]
);
```

## MINI-APP INTEGRATION

### Telegram InitData Validation
```javascript
function validateInitData(initData) {
  const parsed = new URLSearchParams(initData);
  const hash = parsed.get('hash');
  parsed.delete('hash');
  const dataCheckString = Array.from(parsed.entries())
    .sort((a, b) => a[0].localeCompare(b[0]))
    .map(([key, value]) => `${key}=${value}`)
    .join('\n');
  const secretKey = crypto.createHmac('sha256', 'WebAppData').update(BOT_TOKEN).digest();
  const computedHash = crypto.createHmac('sha256', secretKey).update(dataCheckString).digest('hex');
  return computedHash === hash;
}
```

## SESSION MANAGEMENT

### Session Creation Pattern (login.js)
```javascript
// Store session data with KMS encryption
const encryptedSessionKey = await kmsService.encryptSessionKey(sessionKey);
await pool.query(
  "UPDATE users SET kms_encrypted_session_key = $1, kms_key_id = $2, session_expiry = $3 WHERE telegram_id = $4",
  [encryptedSessionKey, kmsKeyId, sessionExpiry, telegram_id]
);
```

## CRITICAL PAIN POINTS

### 1. Database Schema Synchronization
- **NEVER** modify database schema without coordinating with Python bot
- Use `DO $$` blocks for idempotent schema updates
- Check `information_schema` before `ALTER TABLE`

### 2. Legacy User Protection
- **ALWAYS** check for existing wallets before creating new ones
- Respect the same safety checks as Python bot
- Never overwrite existing Turnkey wallet data

### 3. KMS Key Consistency
- **ALWAYS** use the same KMS key ID: `27958fe3-0f3f-44d4-b21d-9d820d5ad96c`
- **NEVER** hardcode KMS keys in code
- Use environment variables for KMS configuration

### 4. Session Data Management
- **ALWAYS** encrypt session keys before storing in database
- **NEVER** store plaintext session keys
- Use consistent encryption/decryption patterns

## ENVIRONMENT VARIABLES

### Required Environment Variables
```bash
# Database
DB_HOST=lumenbro-turnkey.cz2imkksk7b4.us-west-1.rds.amazonaws.com
DB_PORT=5434
DB_NAME=postgres
DB_USER=botadmin
DB_PASSWORD=<password>

# AWS
AWS_REGION=us-west-1
KMS_KEY_ID=27958fe3-0f3f-44d4-b21d-9d820d5ad96c

# Telegram
TELEGRAM_BOT_TOKEN=<bot_token>

# Turnkey
TURNKEY_API_PUBLIC_KEY=<public_key>
TURNKEY_API_PRIVATE_KEY=<private_key>
TURNKEY_ORGANIZATION_ID=<org_id>
```

## DEPLOYMENT CHECKLIST

### Before Deploying Node.js Changes
1. âœ… Verify database schema matches Python bot
2. âœ… Test KMS encryption/decryption
3. âœ… Verify legacy user safety checks
4. âœ… Test session creation and storage
5. âœ… Verify Turnkey API integration
6. âœ… Test mini-app registration flow

### After Deploying
1. âœ… Monitor Python bot logs for session issues
2. âœ… Verify legacy user migration flows
3. âœ… Test wallet creation safety checks
4. âœ… Monitor KMS usage and costs

## COMMON ISSUES & SOLUTIONS

### 1. Database Connection Issues
- **Issue**: SSL certificate errors
- **Solution**: Use `global-bundle.pem` for SSL context

### 2. KMS Permission Errors
- **Issue**: `AccessDenied` for KMS operations
- **Solution**: Verify IAM role has proper KMS permissions

### 3. Session Decryption Failures
- **Issue**: Python bot can't decrypt session keys
- **Solution**: Verify same KMS key ID and encryption format

### 4. Legacy User Conflicts
- **Issue**: Users getting duplicate wallets
- **Solution**: Always check existing wallets before creation

## COORDINATION WITH PYTHON BOT

### Shared Responsibilities
- **Node.js**: Wallet creation, session management, KMS encryption
- **Python**: Trading operations, session decryption, legacy user handling

### Critical Integration Points
1. **Session Data**: Node.js encrypts, Python decrypts
2. **Wallet Creation**: Node.js creates, Python uses for trading
3. **Legacy Users**: Both respect same safety checks
4. **Database Schema**: Both must use identical schema

## ERROR HANDLING

### Common Issues
- **Database schema mismatches**: Always coordinate with Python bot
- **KMS encryption failures**: Verify key ID and permissions
- **Session creation errors**: Check Turnkey API responses
- **Legacy user conflicts**: Always check existing wallets

### Debugging
- Check Node.js logs for KMS and database errors
- Verify Python bot can decrypt session keys
- Monitor Turnkey API responses for wallet creation
- Test legacy user flows end-to-end

## SECURITY CONSIDERATIONS

### Sensitive Data
- Never commit `.env` files or AWS credentials
- Use KMS for encrypting session keys
- Validate all Telegram initData
- Secure Turnkey API key storage

### User Data Protection
- Legacy users get export-only access
- New users get multi-wallet support
- Safety checks prevent accidental data loss
- Clear separation between legacy and new user flows

## FUTURE-PROOFING

### Multi-Wallet Support
- Node.js creates wallets, Python manages switching
- Legacy users restricted for security
- Session management supports multiple wallets
- Active wallet selection for trading

### Python Integration
- `auth.js` has existing wallet creation checks
- `login.js` handles Turnkey session management
- Node.js-side safety checks complement Python checks
- No conflicts between Node.js and Python safety mechanisms
